<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Breakout Game - Raha AI Edition</title>
  <style>
    body{
      background:#121212;color:#fff;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;
      display:flex;flex-direction:column;align-items:center;justify-content:center;
      height:100vh;margin:0;overflow:hidden;
      -webkit-user-select:none; user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    h1{font-size:24px;margin:0 0 12px;text-shadow:0 0 10px rgba(0,173,239,.5)}
    .game-container{
      position:relative;box-shadow:0 0 20px rgba(0,0,0,.8);
      border:2px solid #333;border-radius:6px;overflow:hidden
    }
    canvas{
      background:#1e1e1e;display:block;max-width:100%;height:auto;
      touch-action:none; /* IMPORTANT: no scroll/zoom while playing */
    }
    .footer{margin-top:12px;font-size:14px;color:#888;font-weight:700}
    .highlight{color:#00ADEF}

    .overlay{
      position:absolute;inset:0;display:flex;align-items:center;justify-content:center;
      background:rgba(0,0,0,.55);backdrop-filter: blur(2px);
      opacity:0;pointer-events:none;transition:.2s;
    }
    .overlay.show{opacity:1;pointer-events:auto}
    .panel{
      width:min(360px,92%);padding:18px 16px;border:1px solid #2a2a2a;border-radius:14px;
      background:rgba(18,18,18,.92);box-shadow:0 0 18px rgba(0,0,0,.6);
      text-align:center;
    }
    .panel h2{margin:0 0 10px;font-size:20px}
    .panel p{margin:6px 0 14px;color:#cfcfcf;font-size:14px;line-height:1.4}
    .btn{
      border:none;border-radius:12px;padding:10px 16px;font-weight:700;
      background:#00ADEF;color:#051018;cursor:pointer;
      box-shadow:0 6px 18px rgba(0,173,239,.25);
    }
    .btn:active{transform:translateY(1px)}
    .small{font-size:12px;color:#a8a8a8;margin-top:10px}
    .kbd{
      display:inline-block;border:1px solid #3a3a3a;border-bottom-width:3px;
      padding:2px 6px;border-radius:6px;font-size:12px;color:#ddd
    }
  </style>
</head>
<body>
  <h1>Breakout Game - Raha AI Edition</h1>

  <div class="game-container">
    <canvas id="myCanvas" width="480" height="320"></canvas>

    <div id="overlay" class="overlay show">
      <div class="panel">
        <h2 id="overlayTitle">Breakout</h2>
        <p id="overlayText">
          Tap <span class="kbd">Play</span> to start.<br/>
          Move: <span class="kbd">Touch & Drag</span> / <span class="kbd">Mouse</span> / <span class="kbd">‚Üê</span><span class="kbd">‚Üí</span>
        </p>
        <button id="playBtn" class="btn">Play</button>
        <div class="small">Powered by <span class="highlight">Raha AI</span></div>
      </div>
    </div>
  </div>

  <div class="footer">Powered by <span class="highlight">Raha AI</span></div>

  <script>
    const canvas = document.getElementById("myCanvas");
    const ctx = canvas.getContext("2d");

    const overlay = document.getElementById("overlay");
    const overlayTitle = document.getElementById("overlayTitle");
    const overlayText  = document.getElementById("overlayText");
    const playBtn = document.getElementById("playBtn");

    // ---- Game constants ----
    const paddleHeight = 10;
    const paddleWidth  = 80;
    const ballRadius   = 8;

    const MAX_LIVES = 9;

    // ---- Game state ----
    let lastTime = 0;
    let running = false;
    let paused = false;
    let gameOver = false;

    let leftPressed = false;
    let rightPressed = false;

    // Pointer (touch + mouse unified)
    let pointerActive = false;
    let pointerX = null;

    // World
    let paddleX = (canvas.width - paddleWidth) / 2;
    let ball = { x: canvas.width/2, y: canvas.height-30, vx: 180, vy: -180 };
    let score = 0;
    let lives = 3;

    // Timer per round
    let roundStartTime = 0;

    // Levels: first easy üòÖ
    const levels = [
      { rows: 3, cols: 5, padding: 10, offsetTop: 34, offsetLeft: 45, brickW: 62, brickH: 18, speed: 170 },
      { rows: 4, cols: 6, padding: 10, offsetTop: 34, offsetLeft: 35, brickW: 60, brickH: 20, speed: 200 },
      { rows: 5, cols: 7, padding: 9,  offsetTop: 32, offsetLeft: 20, brickW: 58, brickH: 18, speed: 230 },
      { rows: 6, cols: 8, padding: 8,  offsetTop: 30, offsetLeft: 12, brickW: 54, brickH: 16, speed: 260 },
      { rows: 7, cols: 9, padding: 7,  offsetTop: 28, offsetLeft: 8,  brickW: 50, brickH: 15, speed: 290 },
    ];
    let levelIndex = 0;
    let bricks = [];

    // ---- Time-based bonus rules (4 time-cases each round) ----
    // You can edit these numbers anytime.
    // Example: Round 1 -> <=18s +2 life, <=28s +1, <=40s +0, else +0
    const timeBonusRules = [
      // Round 1
      [
        { maxSec: 18, bonus: 2 },
        { maxSec: 28, bonus: 1 },
        { maxSec: 40, bonus: 0 },
        { maxSec: Infinity, bonus: 0 },
      ],
      // Round 2
      [
        { maxSec: 22, bonus: 2 },
        { maxSec: 34, bonus: 1 },
        { maxSec: 48, bonus: 0 },
        { maxSec: Infinity, bonus: 0 },
      ],
      // Round 3
      [
        { maxSec: 26, bonus: 2 },
        { maxSec: 40, bonus: 1 },
        { maxSec: 55, bonus: 0 },
        { maxSec: Infinity, bonus: 0 },
      ],
      // Round 4
      [
        { maxSec: 30, bonus: 2 },
        { maxSec: 46, bonus: 1 },
        { maxSec: 62, bonus: 0 },
        { maxSec: Infinity, bonus: 0 },
      ],
      // Round 5
      [
        { maxSec: 34, bonus: 2 },
        { maxSec: 52, bonus: 1 },
        { maxSec: 70, bonus: 0 },
        { maxSec: Infinity, bonus: 0 },
      ],
    ];

    // ---- Helpers ----
    function showOverlay(title, text, btnLabel = "Play") {
      overlayTitle.textContent = title;
      overlayText.innerHTML = text;
      playBtn.textContent = btnLabel;
      overlay.classList.add("show");
    }
    function hideOverlay() { overlay.classList.remove("show"); }

    function normalizeToCanvasX(clientX) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      return (clientX - rect.left) * scaleX;
    }

    function circleRectCollision(cx, cy, cr, rx, ry, rw, rh) {
      const closestX = Math.max(rx, Math.min(cx, rx + rw));
      const closestY = Math.max(ry, Math.min(cy, ry + rh));
      const dx = cx - closestX;
      const dy = cy - closestY;
      return (dx*dx + dy*dy) <= cr*cr;
    }

    function setupLevel(idx) {
      const L = levels[idx];
      bricks = [];
      for (let c = 0; c < L.cols; c++) {
        bricks[c] = [];
        for (let r = 0; r < L.rows; r++) bricks[c][r] = { x: 0, y: 0, status: 1 };
      }

      paddleX = (canvas.width - paddleWidth) / 2;
      ball.x = canvas.width/2;
      ball.y = canvas.height - 30;

      const dirX = ball.vx >= 0 ? 1 : -1;
      ball.vx = dirX * L.speed;
      ball.vy = -Math.abs(L.speed);

      // ‚úÖ Round start time reset
      roundStartTime = performance.now();
    }

    function scoreForThisLevel() {
      const L = levels[levelIndex];
      let destroyed = 0;
      for (let c = 0; c < L.cols; c++)
        for (let r = 0; r < L.rows; r++)
          destroyed += (bricks[c][r].status === 0 ? 1 : 0);
      return destroyed;
    }

    function getTimeBonusForLevel(levelIdx, elapsedSec) {
      const rules = timeBonusRules[levelIdx] || timeBonusRules[timeBonusRules.length - 1];
      for (const r of rules) {
        if (elapsedSec <= r.maxSec) return r.bonus;
      }
      return 0;
    }

    function nextLevelOrWin() {
      const elapsedSec = (performance.now() - roundStartTime) / 1000;
      const bonus = getTimeBonusForLevel(levelIndex, elapsedSec);

      if (levelIndex < levels.length - 1) {
        levelIndex++;

        // ‚úÖ time-based bonus life
        lives = Math.min(MAX_LIVES, lives + bonus);

        setupLevel(levelIndex);
        paused = true;

        showOverlay(
          `Round ${levelIndex + 1} ‡¶∂‡ßÅ‡¶∞‡ßÅ!`,
          `Round cleared in <span class="highlight">${elapsedSec.toFixed(1)}s</span><br/>
           Bonus Life: <span class="highlight">+${bonus}</span> ‚úÖ | Lives now: <span class="highlight">${lives}</span><br/>
           Tap <span class="kbd">Play</span> to continue.`,
          "Play"
        );
      } else {
        gameOver = true;
        running = false;
        showOverlay(
          "Winner! üéâ",
          `You cleared all rounds!<br/>
           Final Score: <span class="highlight">${score}</span><br/>
           Tap <span class="kbd">Play Again</span> to restart.`,
          "Play Again"
        );
      }
    }

    function resetAfterLifeLost() {
      paddleX = (canvas.width - paddleWidth) / 2;
      ball.x = canvas.width / 2;
      ball.y = canvas.height - 30;

      const sp = levels[levelIndex].speed;
      ball.vx = (Math.random() < 0.5 ? -1 : 1) * sp;
      ball.vy = -sp;

      // Optional: keep timer running (don‚Äôt reset roundStartTime)
      // If you want: losing a life resets timer -> roundStartTime = performance.now();
    }

    // ---- Input: Keyboard ----
    document.addEventListener("keydown", (e) => {
      if (e.key === "ArrowRight" || e.key === "Right") rightPressed = true;
      if (e.key === "ArrowLeft"  || e.key === "Left")  leftPressed = true;

      if (e.key === " " || e.code === "Space") {
        if (!running || gameOver) return;
        paused = !paused;
        if (paused) showOverlay("Paused", "Press <span class='kbd'>Space</span> or tap <span class='kbd'>Resume</span>.", "Resume");
        else hideOverlay();
      }
    });
    document.addEventListener("keyup", (e) => {
      if (e.key === "ArrowRight" || e.key === "Right") rightPressed = false;
      if (e.key === "ArrowLeft"  || e.key === "Left")  leftPressed  = false;
    });

    // ---- Input: Pointer events (touch + mouse unified) ----
    canvas.addEventListener("pointerdown", (e) => {
      canvas.setPointerCapture(e.pointerId);
      pointerActive = true;
      pointerX = normalizeToCanvasX(e.clientX);
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!pointerActive) return;
      pointerX = normalizeToCanvasX(e.clientX);
    });

    canvas.addEventListener("pointerup", () => {
      pointerActive = false;
      // keep pointerX (last position feel)
    });

    canvas.addEventListener("pointercancel", () => {
      pointerActive = false;
    });

    // ---- Overlay controls ----
    playBtn.addEventListener("click", () => {
      if (gameOver) {
        levelIndex = 0;
        score = 0;
        lives = 3;
        gameOver = false;
        paused = false;
        setupLevel(levelIndex);
      }
      running = true;
      paused = false;
      hideOverlay();
      lastTime = performance.now();
      requestAnimationFrame(loop);
    });

    overlay.addEventListener("click", (e) => {
      if (e.target === playBtn) return;
      playBtn.click();
    });

    // ---- Draw ----
    function drawHUD() {
      ctx.font = "14px Arial";
      ctx.fillStyle = "#ffffff";

      // Timer (live)
      const elapsedSec = (performance.now() - roundStartTime) / 1000;
      const timeText = `Time: ${elapsedSec.toFixed(1)}s`;

      ctx.fillText(`Score: ${score}`, 8, 18);
      ctx.fillText(`Lives: ${lives}`, canvas.width - 70, 18);
      ctx.fillText(`Round: ${levelIndex + 1}/${levels.length}`, canvas.width/2 - 50, 18);

      // Put timer under center line for readability
      ctx.font = "12px Arial";
      ctx.fillStyle = "#cfcfcf";
      ctx.fillText(timeText, canvas.width/2 - 38, 34);
    }

    function drawBall() {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
      ctx.fillStyle = "#00ADEF";
      ctx.fill();
      ctx.closePath();
    }

    function drawPaddle() {
      ctx.beginPath();
      ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
      ctx.closePath();
    }

    function drawBricks() {
      const L = levels[levelIndex];
      for (let c = 0; c < L.cols; c++) {
        for (let r = 0; r < L.rows; r++) {
          if (bricks[c][r].status === 1) {
            const brickX = (c * (L.brickW + L.padding)) + L.offsetLeft;
            const brickY = (r * (L.brickH + L.padding)) + L.offsetTop;
            bricks[c][r].x = brickX;
            bricks[c][r].y = brickY;

            ctx.beginPath();
            ctx.rect(brickX, brickY, L.brickW, L.brickH);
            const g = ctx.createLinearGradient(brickX, brickY, brickX, brickY + L.brickH);
            g.addColorStop(0, "#ff5f6d");
            g.addColorStop(1, "#ffc371");
            ctx.fillStyle = g;
            ctx.fill();
            ctx.closePath();
          }
        }
      }
    }

    // ---- Brick collisions ----
    function handleBrickCollisions() {
      const L = levels[levelIndex];
      for (let c = 0; c < L.cols; c++) {
        for (let r = 0; r < L.rows; r++) {
          const b = bricks[c][r];
          if (b.status !== 1) continue;

          if (circleRectCollision(ball.x, ball.y, ballRadius, b.x, b.y, L.brickW, L.brickH)) {
            b.status = 0;
            score++;

            const midX = b.x + L.brickW / 2;
            const midY = b.y + L.brickH / 2;
            const diffX = ball.x - midX;
            const diffY = ball.y - midY;

            if (Math.abs(diffX) > Math.abs(diffY)) ball.vx *= -1;
            else ball.vy *= -1;

            const total = L.rows * L.cols;
            if (scoreForThisLevel() >= total) nextLevelOrWin();
            return;
          }
        }
      }
    }

    // ---- Update ----
    function update(dt) {
      // Paddle: pointer has priority, then keyboard
      const paddleSpeed = 420; // px/sec

      if (pointerX !== null) {
        const target = pointerX - paddleWidth / 2;
        paddleX += (target - paddleX) * Math.min(1, dt * (pointerActive ? 18 : 10));
      } else {
        if (rightPressed) paddleX += paddleSpeed * dt;
        if (leftPressed)  paddleX -= paddleSpeed * dt;
      }
      paddleX = Math.max(0, Math.min(canvas.width - paddleWidth, paddleX));

      // Ball move
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;

      // Walls
      if (ball.x < ballRadius) { ball.x = ballRadius; ball.vx *= -1; }
      if (ball.x > canvas.width - ballRadius) { ball.x = canvas.width - ballRadius; ball.vx *= -1; }
      if (ball.y < ballRadius) { ball.y = ballRadius; ball.vy *= -1; }

      // ---- Paddle collision FIX (no early bounce) ----
      const paddleY = canvas.height - paddleHeight;

      const ballComingDown = ball.vy > 0;
      const withinPaddleX = ball.x >= paddleX - ballRadius && ball.x <= paddleX + paddleWidth + ballRadius;

      const touchesPaddleTop =
        (ball.y + ballRadius) >= paddleY &&
        (ball.y + ballRadius) <= (paddleY + paddleHeight + 2);

      if (ballComingDown && withinPaddleX && touchesPaddleTop) {
        ball.y = paddleY - ballRadius - 0.5;
        ball.vy = -Math.abs(ball.vy);

        const hitPos = (ball.x - (paddleX + paddleWidth/2)) / (paddleWidth/2);
        const sp = Math.hypot(ball.vx, ball.vy);
        const maxAngle = Math.PI * 0.35;
        const angle = hitPos * maxAngle;
        ball.vx = sp * Math.sin(angle);
        ball.vy = -sp * Math.cos(angle);
      }

      // Bottom (lose life)
      if (ball.y > canvas.height + ballRadius) {
        lives--;
        if (lives <= 0) {
          gameOver = true;
          running = false;
          showOverlay(
            "GAME OVER üòµ",
            `Better Luck Next Time!<br/>Final Score: <span class="highlight">${score}</span><br/>Tap <span class="kbd">Play Again</span> to restart.`,
            "Play Again"
          );
          return;
        } else {
          paused = true;
          resetAfterLifeLost();
          showOverlay(
            "Life Lost!",
            `Lives left: <span class="highlight">${lives}</span><br/>Tap <span class="kbd">Resume</span> to continue.`,
            "Resume"
          );
        }
      }

      handleBrickCollisions();
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBricks();
      drawBall();
      drawPaddle();
      drawHUD();
    }

    function loop(t) {
      if (!running) return;
      const dt = Math.min(0.033, (t - lastTime) / 1000);
      lastTime = t;

      if (!paused && !gameOver) update(dt);
      render();

      requestAnimationFrame(loop);
    }

    // ---- Init ----
    setupLevel(levelIndex);
    showOverlay(
      "Breakout - Raha AI Edition",
      `Mobile friendly ‚úÖ<br/>
       Move: <span class="kbd">Touch & Drag</span><br/>
       Round 1 is easy üòÖ<br/>
       Bonus lives depend on time ‚è±Ô∏è`,
      "Play"
    );
  </script>
</body>
                                                                         </html>
