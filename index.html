<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Breakout Game - Raha AI Edition</title>
  <style>
    body{
      background:#121212;color:#fff;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;
      display:flex;flex-direction:column;align-items:center;justify-content:center;
      height:100vh;margin:0;overflow:hidden;
      /* mobile: reduce accidental selection */
      -webkit-user-select:none; user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    h1{font-size:24px;margin:0 0 12px;text-shadow:0 0 10px rgba(0,173,239,.5)}
    .game-container{position:relative;box-shadow:0 0 20px rgba(0,0,0,.8);border:2px solid #333;border-radius:6px;overflow:hidden}
    canvas{
      background:#1e1e1e;display:block;max-width:100%;height:auto;
      /* IMPORTANT for mobile gestures */
      touch-action: none;
    }
    .footer{margin-top:12px;font-size:14px;color:#888;font-weight:700}
    .highlight{color:#00ADEF}

    .overlay{
      position:absolute;inset:0;display:flex;align-items:center;justify-content:center;
      background:rgba(0,0,0,.55);backdrop-filter: blur(2px);
      opacity:0;pointer-events:none;transition:.2s;
    }
    .overlay.show{opacity:1;pointer-events:auto}
    .panel{
      width:min(360px,92%);padding:18px 16px;border:1px solid #2a2a2a;border-radius:14px;
      background:rgba(18,18,18,.92);box-shadow:0 0 18px rgba(0,0,0,.6);
      text-align:center;
    }
    .panel h2{margin:0 0 10px;font-size:20px}
    .panel p{margin:6px 0 14px;color:#cfcfcf;font-size:14px;line-height:1.4}
    .btn{
      border:none;border-radius:12px;padding:10px 16px;font-weight:700;
      background:#00ADEF;color:#051018;cursor:pointer;
      box-shadow:0 6px 18px rgba(0,173,239,.25);
    }
    .btn:active{transform:translateY(1px)}
    .small{font-size:12px;color:#a8a8a8;margin-top:10px}
    .kbd{display:inline-block;border:1px solid #3a3a3a;border-bottom-width:3px;padding:2px 6px;border-radius:6px;font-size:12px;color:#ddd}
  </style>
</head>
<body>
  <h1>Breakout Game - Raha AI Edition</h1>

  <div class="game-container">
    <canvas id="myCanvas" width="480" height="320"></canvas>

    <div id="overlay" class="overlay show">
      <div class="panel">
        <h2 id="overlayTitle">Breakout</h2>
        <p id="overlayText">
          Tap <span class="kbd">Play</span> to start.<br/>
          Move: <span class="kbd">Touch</span> / <span class="kbd">Mouse</span> / <span class="kbd">‚Üê</span><span class="kbd">‚Üí</span>
        </p>
        <button id="playBtn" class="btn">Play</button>
        <div class="small">Powered by <span class="highlight">Raha AI</span></div>
      </div>
    </div>
  </div>

  <div class="footer">Powered by <span class="highlight">Raha AI</span></div>

  <script>
    const canvas = document.getElementById("myCanvas");
    const ctx = canvas.getContext("2d");

    const overlay = document.getElementById("overlay");
    const overlayTitle = document.getElementById("overlayTitle");
    const overlayText  = document.getElementById("overlayText");
    const playBtn = document.getElementById("playBtn");

    const paddleHeight = 10;
    const paddleWidth = 80;
    const ballRadius = 8;

    let lastTime = 0;
    let running = false;
    let paused = false;
    let gameOver = false;

    // Input
    let leftPressed = false;
    let rightPressed = false;
    let mouseX = null;

    // Touch state
    let isTouching = false;
    let touchX = null;

    // World
    let paddleX = (canvas.width - paddleWidth) / 2;
    let ball = { x: canvas.width/2, y: canvas.height-30, vx: 180, vy: -180 };
    let score = 0;
    let lives = 3;

    const levels = [
      { rows: 3, cols: 5, padding: 10, offsetTop: 34, offsetLeft: 45, brickW: 62, brickH: 18, speed: 170 },
      { rows: 4, cols: 6, padding: 10, offsetTop: 34, offsetLeft: 35, brickW: 60, brickH: 20, speed: 200 },
      { rows: 5, cols: 7, padding: 9,  offsetTop: 32, offsetLeft: 20, brickW: 58, brickH: 18, speed: 230 },
      { rows: 6, cols: 8, padding: 8,  offsetTop: 30, offsetLeft: 12, brickW: 54, brickH: 16, speed: 260 },
      { rows: 7, cols: 9, padding: 7,  offsetTop: 28, offsetLeft: 8,  brickW: 50, brickH: 15, speed: 290 },
    ];

    let levelIndex = 0;
    let bricks = [];

    function setupLevel(idx) {
      const L = levels[idx];
      bricks = [];
      for (let c = 0; c < L.cols; c++) {
        bricks[c] = [];
        for (let r = 0; r < L.rows; r++) bricks[c][r] = { x: 0, y: 0, status: 1 };
      }

      paddleX = (canvas.width - paddleWidth) / 2;
      ball.x = canvas.width/2;
      ball.y = canvas.height-30;

      const dirX = ball.vx >= 0 ? 1 : -1;
      ball.vx = dirX * L.speed;
      ball.vy = -Math.abs(L.speed);
    }

    function showOverlay(title, text, btnLabel = "Play") {
      overlayTitle.textContent = title;
      overlayText.innerHTML = text;
      playBtn.textContent = btnLabel;
      overlay.classList.add("show");
    }
    function hideOverlay() { overlay.classList.remove("show"); }

    function normalizeToCanvasX(clientX) {
      // Map touch/mouse clientX to canvas coordinate system accurately (even when scaled)
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      return (clientX - rect.left) * scaleX;
    }

    // ---------- Keyboard ----------
    document.addEventListener("keydown", (e) => {
      if (e.key === "ArrowRight" || e.key === "Right") rightPressed = true;
      if (e.key === "ArrowLeft"  || e.key === "Left")  leftPressed = true;

      if (e.key === " " || e.code === "Space") {
        if (!running || gameOver) return;
        paused = !paused;
        if (paused) showOverlay("Paused", "Press <span class='kbd'>Space</span> or tap <span class='kbd'>Resume</span>.", "Resume");
        else hideOverlay();
      }
    });
    document.addEventListener("keyup", (e) => {
      if (e.key === "ArrowRight" || e.key === "Right") rightPressed = false;
      if (e.key === "ArrowLeft"  || e.key === "Left")  leftPressed  = false;
    });

    // ---------- Mouse ----------
    document.addEventListener("mousemove", (e) => {
      // Mouse works only if not touching
      if (isTouching) return;
      mouseX = normalizeToCanvasX(e.clientX);
    });

    // ---------- Touch (Mobile) ----------
    // We attach to canvas so page doesn't scroll while playing
    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      isTouching = true;
      const t = e.changedTouches[0];
      touchX = normalizeToCanvasX(t.clientX);

      // Quick UX: if game not started / paused overlay visible, a tap starts/resumes
      // (avoid tapping UI button only)
      if (overlay.classList.contains("show") && !gameOver) {
        // do nothing; user can tap Play/Resume button
      }
    }, { passive: false });

    canvas.addEventListener("touchmove", (e) => {
      e.preventDefault();
      const t = e.changedTouches[0];
      touchX = normalizeToCanvasX(t.clientX);
    }, { passive: false });

    canvas.addEventListener("touchend", (e) => {
      e.preventDefault();
      // keep last touchX so paddle stays where user left it
      // but mark not touching so mouse can work again (desktop)
      isTouching = false;
    }, { passive: false });

    // ---------- Overlay Button ----------
    playBtn.addEventListener("click", () => {
      if (gameOver) {
        levelIndex = 0;
        score = 0;
        lives = 3;
        gameOver = false;
        paused = false;
        setupLevel(levelIndex);
      }
      running = true;
      paused = false;
      hideOverlay();
      lastTime = performance.now();
      requestAnimationFrame(loop);
    });

    // Bonus: tap overlay panel anywhere to play/resume (mobile friendly)
    overlay.addEventListener("click", (e) => {
      // allow click on panel to also start/resume
      if (e.target === playBtn) return;
      playBtn.click();
    });

    // ---------- Draw ----------
    function drawScoreLivesLevel() {
      ctx.font = "14px Arial";
      ctx.fillStyle = "#ffffff";
      ctx.fillText(`Score: ${score}`, 8, 18);
      ctx.fillText(`Lives: ${lives}`, canvas.width - 70, 18);
      ctx.fillText(`Round: ${levelIndex + 1}/${levels.length}`, canvas.width/2 - 50, 18);
    }

    function drawBall() {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
      ctx.fillStyle = "#00ADEF";
      ctx.fill();
      ctx.closePath();
    }

    function drawPaddle() {
      ctx.beginPath();
      ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
      ctx.closePath();
    }

    function drawBricks() {
      const L = levels[levelIndex];
      for (let c = 0; c < L.cols; c++) {
        for (let r = 0; r < L.rows; r++) {
          if (bricks[c][r].status === 1) {
            const brickX = (c * (L.brickW + L.padding)) + L.offsetLeft;
            const brickY = (r * (L.brickH + L.padding)) + L.offsetTop;
            bricks[c][r].x = brickX;
            bricks[c][r].y = brickY;

            ctx.beginPath();
            ctx.rect(brickX, brickY, L.brickW, L.brickH);
            const g = ctx.createLinearGradient(brickX, brickY, brickX, brickY + L.brickH);
            g.addColorStop(0, "#ff5f6d");
            g.addColorStop(1, "#ffc371");
            ctx.fillStyle = g;
            ctx.fill();
            ctx.closePath();
          }
        }
      }
    }

    // ---------- Collision ----------
    function circleRectCollision(cx, cy, cr, rx, ry, rw, rh) {
      const closestX = Math.max(rx, Math.min(cx, rx + rw));
      const closestY = Math.max(ry, Math.min(cy, ry + rh));
      const dx = cx - closestX;
      const dy = cy - closestY;
      return (dx*dx + dy*dy) <= cr*cr;
    }

    function scoreForThisLevel() {
      const L = levels[levelIndex];
      let destroyed = 0;
      for (let c = 0; c < L.cols; c++)
        for (let r = 0; r < L.rows; r++)
          destroyed += (bricks[c][r].status === 0 ? 1 : 0);
      return destroyed;
    }

    function nextLevelOrWin() {
      if (levelIndex < levels.length - 1) {
        levelIndex++;
        setupLevel(levelIndex);
        paused = true;
        showOverlay(
          `Round ${levelIndex} ‡¶∂‡ßÅ‡¶∞‡ßÅ!`,
          `Nice! üéâ Next round is harder.<br/>Tap <span class="kbd">Play</span> to continue.`,
          "Play"
        );
      } else {
        gameOver = true;
        running = false;
        showOverlay(
          "Winner! üéâ",
          `You cleared all rounds!<br/>Final Score: <span class="highlight">${score}</span><br/>Tap <span class="kbd">Play Again</span> to restart.`,
          "Play Again"
        );
      }
    }

    function handleBrickCollisions() {
      const L = levels[levelIndex];
      for (let c = 0; c < L.cols; c++) {
        for (let r = 0; r < L.rows; r++) {
          const b = bricks[c][r];
          if (b.status !== 1) continue;

          if (circleRectCollision(ball.x, ball.y, ballRadius, b.x, b.y, L.brickW, L.brickH)) {
            b.status = 0;
            score++;

            const midX = b.x + L.brickW / 2;
            const midY = b.y + L.brickH / 2;
            const diffX = ball.x - midX;
            const diffY = ball.y - midY;

            if (Math.abs(diffX) > Math.abs(diffY)) ball.vx *= -1;
            else ball.vy *= -1;

            const total = L.rows * L.cols;
            if (scoreForThisLevel() >= total) nextLevelOrWin();
            return;
          }
        }
      }
    }

    function resetAfterLifeLost() {
      paddleX = (canvas.width - paddleWidth) / 2;
      ball.x = canvas.width / 2;
      ball.y = canvas.height - 30;

      const sp = levels[levelIndex].speed;
      ball.vx = (Math.random() < 0.5 ? -1 : 1) * sp;
      ball.vy = -sp;
    }

    // ---------- Loop ----------
    function update(dt) {
      // Touch has priority, then mouse, then keyboard
      const paddleSpeed = 420; // px/sec

      if (touchX !== null && isTouching) {
        const target = touchX - paddleWidth / 2;
        paddleX += (target - paddleX) * Math.min(1, dt * 18); // slightly stronger smoothing for touch
      } else if (mouseX !== null && !isTouching) {
        const target = mouseX - paddleWidth / 2;
        paddleX += (target - paddleX) * Math.min(1, dt * 12);
      } else {
        if (rightPressed) paddleX += paddleSpeed * dt;
        if (leftPressed)  paddleX -= paddleSpeed * dt;
      }

      paddleX = Math.max(0, Math.min(canvas.width - paddleWidth, paddleX));

      // Ball move
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;

      // Walls
      if (ball.x < ballRadius) { ball.x = ballRadius; ball.vx *= -1; }
      if (ball.x > canvas.width - ballRadius) { ball.x = canvas.width - ballRadius; ball.vx *= -1; }
      if (ball.y < ballRadius) { ball.y = ballRadius; ball.vy *= -1; }

      // Paddle collision
      const paddleY = canvas.height - paddleHeight;
      if (circleRectCollision(ball.x, ball.y, ballRadius, paddleX, paddleY, paddleWidth, paddleHeight)) {
        ball.y = paddleY - ballRadius - 0.5;
        ball.vy = -Math.abs(ball.vy);

        const hitPos = (ball.x - (paddleX + paddleWidth/2)) / (paddleWidth/2); // -1..1
        const sp = Math.hypot(ball.vx, ball.vy);
        const maxAngle = Math.PI * 0.35;
        const angle = hitPos * maxAngle;
        ball.vx = sp * Math.sin(angle);
        ball.vy = -sp * Math.cos(angle);
      }

      // Bottom
      if (ball.y > canvas.height + ballRadius) {
        lives--;
        if (lives <= 0) {
          gameOver = true;
          running = false;
          showOverlay(
            "GAME OVER üòµ",
            `Better Luck Next Time!<br/>Final Score: <span class="highlight">${score}</span><br/>Tap <span class="kbd">Play Again</span> to restart.`,
            "Play Again"
          );
          return;
        } else {
          paused = true;
          resetAfterLifeLost();
          showOverlay(
            "Life Lost!",
            `Lives left: <span class="highlight">${lives}</span><br/>Tap <span class="kbd">Resume</span> to continue.`,
            "Resume"
          );
        }
      }

      handleBrickCollisions();
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBricks();
      drawBall();
      drawPaddle();
      drawScoreLivesLevel();
    }

    function loop(t) {
      if (!running) return;
      const dt = Math.min(0.033, (t - lastTime) / 1000);
      lastTime = t;

      if (!paused && !gameOver) update(dt);
      render();

      requestAnimationFrame(loop);
    }

    // ---------- Init ----------
    setupLevel(levelIndex);
    showOverlay(
      "Breakout - Raha AI Edition",
      `Mobile friendly ‚úÖ<br/>
       Move: <span class="kbd">Touch & Drag</span><br/>
       Pause: <span class="kbd">Space</span> (Desktop)`,
      "Play"
    );
  </script>
</body>
</html>
